---
name: massdriver
description: Helps develop Massdriver bundles, artifact definitions, and platform integrations. Auto-activates when working with massdriver.yaml, bundles/, artifact-definitions/, or platforms/ directories. Provides patterns, scaffolding guidance, and validation rules for the Massdriver catalog.
---

# Massdriver Bundle Development

You are helping develop infrastructure bundles and artifact definitions for Massdriver. This skill provides patterns, guard rails, and workflows for the massdriver-catalog repository.

## Auto-Activation Triggers

This skill should be loaded when:
- Working in `bundles/` or `artifact-definitions/` or `platforms/` directories
- Editing `massdriver.yaml` files
- User asks about bundles, artifacts, connections, or Massdriver patterns

## Core Concepts

**Bundle**: Reusable IaC module with declarative configuration (`massdriver.yaml` + `src/` code)

**Artifact Definition**: Schema contract defining how bundles connect (`artifact-definitions/*/massdriver.yaml`)

**Platform**: Cloud credential schema for authentication (`platforms/*/massdriver.yaml`)

**Key Flow**: Edit `massdriver.yaml` → `mass bundle build` (generates schemas) → `tofu validate` → `mass bundle publish`

## Critical Rules

### 1. NEVER Edit Generated Files
These files are auto-generated by `mass bundle build` - changes will be overwritten:
- `schema-*.json` - Generated from massdriver.yaml sections
- `_massdriver_variables.tf` - Generated from params + connections schemas

### 2. Namespace Collision Warning
**Params and connections share the same Terraform variable namespace.**

```yaml
# BAD - These will conflict as var.network in Terraform
params:
  properties:
    network:          # Creates var.network
connections:
  properties:
    network:          # Also creates var.network - COLLISION!
```

Always use distinct names for params and connections.

### 3. Artifact $ref Must Match Definition Name
The `$ref` value must exactly match the artifact definition directory name:

```yaml
# massdriver.yaml
connections:
  properties:
    network:
      $ref: network  # References artifact-definitions/network/massdriver.yaml
```

### 4. artifacts.tf Must Match massdriver.yaml
Every entry in `massdriver.yaml` artifacts section needs a corresponding `massdriver_artifact` resource:

```yaml
# massdriver.yaml
artifacts:
  properties:
    database:         # <-- field name
      $ref: postgres
```

```hcl
# src/artifacts.tf
resource "massdriver_artifact" "database" {
  field = "database"  # <-- Must match the field name above
  # ...
}
```

### 5. Always Include massdriver Provider

```hcl
terraform {
  required_providers {
    massdriver = {
      source  = "massdriver-cloud/massdriver"
      version = "~> 1.3"
    }
  }
}
```

## File Responsibilities

| File | Purpose | Editable? |
|------|---------|-----------|
| `massdriver.yaml` | Source of truth - params, connections, artifacts, UI | Yes |
| `src/main.tf` | Your IaC code (resources, data sources) | Yes |
| `src/artifacts.tf` | massdriver_artifact resources | Yes |
| `operator.md` | Runbook with mustache templating | Yes |
| `icon.svg` | Bundle icon | Yes |
| `schema-*.json` | Generated schemas | **Never** |
| `_massdriver_variables.tf` | Generated variables | **Never** |

## Quick Start Workflows

### Creating a New Bundle

1. Create bundle directory:
   ```bash
   mkdir -p bundles/my-bundle/src
   ```

2. Create `massdriver.yaml` (see `snippets/massdriver-yaml.yaml` for template)

3. Create `src/main.tf` with your infrastructure code

4. Create `src/artifacts.tf` with `massdriver_artifact` resources for each artifact

5. Create `operator.md` for operational runbook

6. Build and validate:
   ```bash
   cd bundles/my-bundle
   mass bundle build
   cd src && tofu init && tofu validate
   ```

7. Publish:
   ```bash
   mass bundle publish
   ```

### Adding a Connection to a Bundle

1. Add connection to `massdriver.yaml`:
   ```yaml
   connections:
     required:
       - network    # Add to required if mandatory
     properties:
       network:
         $ref: network
         title: Network
   ```

2. Rebuild to generate variables:
   ```bash
   mass bundle build
   ```

3. Use connection data in Terraform:
   ```hcl
   # Connection becomes a variable with artifact's structure
   resource "example" "main" {
     vpc_id     = var.network.id
     subnet_ids = [for s in var.network.subnets : s.id]
   }
   ```

### Creating an Artifact Definition

1. Create directory and `massdriver.yaml`:
   ```bash
   mkdir -p artifact-definitions/my-artifact
   ```

2. Create `artifact-definitions/my-artifact/massdriver.yaml`:
   ```yaml
   name: my-artifact
   label: My Artifact

   schema:
     title: My Artifact
     description: Description of what this artifact represents
     type: object
     required:
       - id
     properties:
       id:
         title: ID
         type: string
   ```

3. Publish:
   ```bash
   mass definition publish artifact-definitions/my-artifact/massdriver.yaml
   ```

## Common Patterns

### Accessing Connection Data in Terraform

```hcl
# Simple field access
var.network.id
var.network.cidr

# Nested object
var.database.auth.hostname
var.database.auth.password

# Array iteration
[for s in var.network.subnets : s.id]
[for s in var.network.subnets : s.id if s.type == "private"]
```

### Creating Artifacts (artifacts.tf)

```hcl
resource "massdriver_artifact" "database" {
  field = "database"  # Must match artifacts property name in massdriver.yaml
  name  = "PostgreSQL ${var.md_metadata.name_prefix}"

  artifact = jsonencode({
    # Structure must match artifact-definitions/postgres/massdriver.yaml schema
    id = aws_rds_cluster.main.id
    auth = {
      hostname = aws_rds_cluster.main.endpoint
      port     = 5432
      database = var.database_name
      username = var.username
      password = random_password.main.result
    }
    policies = [
      { id = "read", name = "Read Only" },
      { id = "write", name = "Read/Write" }
    ]
  })
}
```

### Sensitive Fields in Artifact Definitions

```yaml
# In artifact-definitions/*/massdriver.yaml schema section
schema:
  properties:
    password:
      $md.sensitive: true
      $md.copyable: false
      title: Password
      type: string
```

### Immutable Fields (Cannot Change After Creation)

```yaml
params:
  properties:
    db_version:
      type: string
      $md.immutable: true  # Cannot be changed after initial deployment
      enum: ["14", "15", "16"]
```

### Dynamic Dropdowns from Connection Data ($md.enum)

```yaml
params:
  properties:
    database_policy:
      type: string
      title: Database Access Policy
      $md.enum:
        connection: database       # Source connection name
        options: .policies         # JSONPath to array
        value: .name              # Field to use as value
```

### UI Ordering

```yaml
ui:
  ui:order:
    - db_version          # Show first
    - database_name
    - username
    - "*"                 # All remaining fields
```

### Using md_metadata

```hcl
# Naming resources
resource "aws_db_instance" "main" {
  identifier = "${var.md_metadata.name_prefix}-postgres"
  tags       = var.md_metadata.default_tags
}

# Available metadata fields
var.md_metadata.name_prefix           # Unique name prefix
var.md_metadata.default_tags          # Tags to apply to resources
var.md_metadata.deployment.id         # Deployment identifier
var.md_metadata.observability.alarm_webhook_url  # Alerting endpoint
```

### Optional Connections

```yaml
# massdriver.yaml - don't add to required array
connections:
  required:
    - network    # Required
  properties:
    network:
      $ref: network
    bucket:
      $ref: bucket  # Optional - not in required array
```

```hcl
# Terraform - check for null
locals {
  has_bucket = var.bucket != null
}

resource "example" "main" {
  bucket_name = local.has_bucket ? var.bucket.name : null
}
```

## Validation Checklist

Before publishing a bundle:

- [ ] `mass bundle build` runs successfully
- [ ] No param/connection name conflicts (check massdriver.yaml)
- [ ] Every artifact has a matching `massdriver_artifact` resource
- [ ] `tofu init && tofu validate` passes
- [ ] Artifact JSON structure matches artifact definition schema
- [ ] Required providers include `massdriver-cloud/massdriver`

## Common Mistakes & Fixes

| Mistake | Fix |
|---------|-----|
| "variable not declared" | Run `mass bundle build` to generate `_massdriver_variables.tf` |
| Param and connection have same name | Rename one - they share Terraform namespace |
| artifacts.tf field doesn't match | Ensure `field = "X"` matches `artifacts.properties.X` in massdriver.yaml |
| $ref not found | Verify artifact definition directory exists with massdriver.yaml |
| Edited generated file, changes lost | Never edit `schema-*.json` or `_massdriver_variables.tf` |
| Missing massdriver provider | Add to `required_providers` block |

## Commands Reference

```bash
# Single bundle operations
cd bundles/my-bundle
mass bundle build           # Generate schemas + _massdriver_variables.tf
tofu init && tofu validate  # Validate IaC
mass bundle publish         # Publish to Massdriver

# Repository-wide operations
make build-bundles          # Build all bundles
make validate-bundles       # Validate all bundles
make publish-bundles        # Publish all bundles
make publish-artifact-definitions  # Publish artifact definitions
make publish-platforms      # Publish platform definitions
make all                    # Clean, build, validate, publish everything
```

## See Also

- [PATTERNS.md](./PATTERNS.md) - Complete examples of bundles and artifact definitions
- [snippets/](./snippets/) - Copy-paste templates for common files
- [CLAUDE.md](../../../CLAUDE.md) - Project-specific conventions (customize for your org)

## Extensibility

Customers can customize patterns for their organization by adding to their project's `CLAUDE.md`:

```markdown
## Our Bundle Conventions

- All bundles must include `cost_center` param
- Use `acme-` prefix for bundle names
- Required tags: team, environment, compliance-scope
```

The skill will incorporate these org-specific patterns when working in that repository.
